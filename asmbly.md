# 어셈블리

## 어셈블리

- C언어 코드를 컴파일 하는 단계에서 어셈블리로 변환됨
    - 42 첫 과제에서 했었음(https://80000coding.oopy.io/c44dfef0-0817-4116-b029-e9786fedd9c7)

- 시스템콜, 메모리 직접 제어, 해킹을 위해 필요함

- CPU가 일하는 방식을 직접 명령함

``` asm

mov rax, 5 ; rax = 5
add rax, 3 ; rax += 3

```


## 진수 변환

- 42 선발과정에서 쉘 스크립트, C언어를 통해 자주 해서 자신있는 부분

## 레지스터

- RAX, RDI, RSI 모두 레지스터

### 레지스터란?

- CPU 내부의 초고속 메모리
- 메모리보다 훨씬 빠름
- 연산, 함수 호출, 주소 전달 등 모든 작업의 중심

### 주요 레지스터

-----------------------------------------------
| RAX | 연산 결과, 반환값 | retrun value        |
| RDI | 함수 첫번째 인자 | char *s와 같은 포인터|
| RSI | 두번째 인자 | write의 buff              |
| RDX | 세번째 인자 | write에서의 len           |
------------------------------------------------

- 필수 개념

```
┌──────────── RAX (64bit) ────────────┐
│     상위 바이트     │   하위 바이트 │
└──────┬──────────────┬───────────────┘
       │              │
     EAX (32bit)      │ ← 아래쪽 4바이트
           AX (16bit) │ ← 아래쪽 2바이트
                AL (8bit) ← 맨 아래 1바이트

```

AL은 AX의 일부 공간, AX는 EAX의 일부 공간, EAX는 RAX의 일부 공간임

64비트니까 RAX가 존재하는거임
32비트 컴퓨터면 EAX까지만 있

- 아래랑 비슷하다고 생각함
    - 구조체에서 바이트 정렬을 했을 경우
    - 세그먼트에서의 오프셋

```
mov rax, 0x12345678abcdef00
```

- RAX = 0x12345678abcdef00
- EAX = 하위 32비트 = 0xabcdef00
- AX = 하위 16비트 = 0xef00
- AL = 하위 8비트 = 0x00

## BUS

CPU, 메모리, SSD, I/O는 BUS라는 선으로 연결됨

- Address Bus: 어디에 접근할 주소 전달
- Data Bus: 데이터를 주고 받음
- Control Bus: 읽기/쓰기 동작 등 명


- 참고 키워드
    - Flat Memory Model
    - Segment:Offset
